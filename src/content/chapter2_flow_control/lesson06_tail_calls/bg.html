<p> Когато се извика функция, се създава нов кадър (stack frame) в паметта, за
  да се запазят аргументите и локалните променливи на функцията. Ако се създават
  много такива кадри по време на рекурсия, програмата би използвала много памет
  или дори може да се срине, ако достигне ограничение за памет. </p>
<p> За да избегнем този проблем, Gleam поддържа <em>оптимизация за опашково
    извикване</em> (tail call optimisation), което позволява на компилатора да
  използва повторно кадъра на текущата функция, ако последното нещо, което
  функцията прави, е да извика себе си. </p>
<p> Неоптимизирани рекурсивни функции често може да се пренапишат така, че да
  станат оптимизирани за опашково извикване чрез използване на
  <em>акумулатор</em>. Акумулаторът е променлива, която се подава заедно с
  данните, подобно на променлива, чиято стойност се променя в езици с цикли
  <code>while</code>. </p>
<p> Акумулаторите трябва да се крият от потребителите на вашия код, те са
  детайли от имплементацията. За целта дефинирайте публична функция, която
  извиква частна рекурсивна функция с първоначалната стойност на акумулатора.
</p>
